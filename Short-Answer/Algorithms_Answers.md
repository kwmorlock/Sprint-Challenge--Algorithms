#### Please add your answers to the ***Analysis of  Algorithms*** exercises here.

## Exercise I

a) O(n) When input increases the runtime will increase at the same rate, not a bad solution compared to some other Big O run times. (In big O notation ignores the plus)


b) O(n^2) Not a good run time, because of nested loops that all rely on n. 
(redo)

new response O(n log n) This is a usable solution that isnt ideal, as the input grows, the runtime
grows at only a slightly faster rate, this is often seen with mergesort


c) O(n) This is a recursive function that runs linear.

## Exercise II

check n//2 floor to check egg breaking (want to round down to nearest whole number)
-if_egg_break = True:
-n[x:] = break_floor
-get floor between len([n1:x]) // 2:
-process goes again
-if_egg_doesnt_break = False:
n[:x] = nonbreak_floor

Logarithmic O(log n)

As input gets bigger runtime/space will increase slower (This is a good solution compared to many other Big O solutions)



